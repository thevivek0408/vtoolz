<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Pipe Puzzle</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0f0f1a;color:#e0e0e0;font-family:'Segoe UI',Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:16px;user-select:none}
h1{font-size:1.5rem;margin-bottom:8px;background:linear-gradient(135deg,#0984e3,#74b9ff);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}
.info{color:#888;font-size:.8rem;margin-bottom:10px;text-align:center}
.stats{display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;justify-content:center;font-size:.85rem}
.stat{background:#1a1a2e;padding:8px 16px;border-radius:20px;border:1px solid #333}
.stat b{color:#74b9ff}
.size-sel{display:flex;gap:6px;margin-bottom:12px}
.size-sel button{background:#1e1e3a;border:1px solid #444;color:#aaa;padding:5px 12px;border-radius:6px;cursor:pointer;font-size:.8rem;transition:all .2s}
.size-sel button.active{border-color:#74b9ff;color:#74b9ff}
canvas{border-radius:8px;border:2px solid #2a2a4e;cursor:pointer;touch-action:none}
.controls{margin-top:12px;display:flex;gap:8px}
.controls button{background:#1e1e3a;border:1px solid #444;color:#e0e0e0;padding:8px 20px;border-radius:8px;cursor:pointer;font-size:.85rem;transition:all .2s}
.controls button:hover{background:#0984e3;border-color:#0984e3;color:#fff}
.win{display:none;font-size:1.2rem;color:#74b9ff;margin-top:12px}
.win.show{display:block}
</style>
</head>
<body>
<h1>Pipe Puzzle</h1>
<div class="info">Rotate pipes to connect water from source üíß to drain. Click/tap to rotate.</div>
<div class="size-sel" id="sizes"></div>
<div class="stats">
  <div class="stat">Moves: <b id="moves">0</b></div>
  <div class="stat">Level: <b id="level">1</b></div>
</div>
<canvas id="c"></canvas>
<div class="controls">
  <button onclick="newPuzzle()">New Puzzle</button>
</div>
<div class="win" id="win">üéâ Water flows! Puzzle solved!</div>
<script>
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
// Directions: 0=top, 1=right, 2=bottom, 3=left
const DR=[[-1,0],[0,1],[1,0],[0,-1]];
const PIPE_TYPES=[
  {name:'straight',openings:[0,2]},  // ‚îÇ
  {name:'straight',openings:[1,3]},  // ‚îÄ
  {name:'elbow',openings:[0,1]},     // ‚îò
  {name:'elbow',openings:[1,2]},     // ‚îê
  {name:'elbow',openings:[2,3]},     // ‚îå
  {name:'elbow',openings:[0,3]},     // ‚îî
  {name:'tee',openings:[0,1,2]},     // ‚îú
  {name:'tee',openings:[1,2,3]},     // ‚î¨
  {name:'tee',openings:[0,2,3]},     // ‚î§
  {name:'tee',openings:[0,1,3]},     // ‚î¥
  {name:'cross',openings:[0,1,2,3]}, // ‚îº
];
let gridSize=5,grid=[],source,drain,moves=0,lvl=1,solved=false,CS;

function buildSizes(){
  const el=document.getElementById('sizes');el.innerHTML='';
  [4,5,6,7].forEach(s=>{
    const b=document.createElement('button');b.textContent=s+'√ó'+s;
    if(s===gridSize)b.classList.add('active');
    b.addEventListener('click',()=>{gridSize=s;lvl=1;newPuzzle();buildSizes()});
    el.appendChild(b);
  });
}

function newPuzzle(){
  moves=0;solved=false;
  document.getElementById('moves').textContent=0;
  document.getElementById('level').textContent=lvl;
  document.getElementById('win').classList.remove('show');
  CS=Math.min(Math.floor((Math.min(window.innerWidth-32,400))/gridSize),60);
  canvas.width=gridSize*CS;canvas.height=gridSize*CS;
  
  // Generate connected solution via random walk
  grid=Array.from({length:gridSize},()=>Array.from({length:gridSize},()=>({openings:[],filled:false})));
  source={r:0,c:0};drain={r:gridSize-1,c:gridSize-1};
  
  // BFS/DFS to create a spanning tree
  let visited=new Set();
  let stack=[[0,0]];visited.add('0,0');
  let edges=[];
  while(stack.length){
    let[r,c]=stack[stack.length-1];
    let neighbors=[];
    for(let d=0;d<4;d++){
      let nr=r+DR[d][0],nc=c+DR[d][1];
      if(nr>=0&&nr<gridSize&&nc>=0&&nc<gridSize&&!visited.has(nr+','+nc)){
        neighbors.push([nr,nc,d]);
      }
    }
    if(neighbors.length===0){stack.pop();continue}
    let[nr,nc,d]=neighbors[Math.floor(Math.random()*neighbors.length)];
    visited.add(nr+','+nc);
    edges.push([r,c,d]);
    grid[r][c].openings.push(d);
    grid[nr][nc].openings.push((d+2)%4);
    stack.push([nr,nc]);
  }
  
  // Scramble rotations
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      let rotations=Math.floor(Math.random()*4);
      for(let i=0;i<rotations;i++){
        grid[r][c].openings=grid[r][c].openings.map(d=>(d+1)%4);
      }
    }
  }
  checkFlow();draw();
}

function rotatePipe(r,c){
  if(solved)return;
  grid[r][c].openings=grid[r][c].openings.map(d=>(d+1)%4);
  moves++;document.getElementById('moves').textContent=moves;
  checkFlow();draw();
  if(solved){
    document.getElementById('win').classList.add('show');
    lvl++;
  }
}

function checkFlow(){
  // BFS from source
  for(let r=0;r<gridSize;r++)for(let c=0;c<gridSize;c++)grid[r][c].filled=false;
  let q=[[source.r,source.c]];
  grid[source.r][source.c].filled=true;
  while(q.length){
    let[r,c]=q.shift();
    for(let d of grid[r][c].openings){
      let nr=r+DR[d][0],nc=c+DR[d][1];
      if(nr<0||nr>=gridSize||nc<0||nc>=gridSize)continue;
      if(grid[nr][nc].filled)continue;
      if(grid[nr][nc].openings.includes((d+2)%4)){
        grid[nr][nc].filled=true;q.push([nr,nc]);
      }
    }
  }
  // Check if all cells are filled
  solved=grid.every(row=>row.every(cell=>cell.filled));
}

function draw(){
  ctx.fillStyle='#0a0a18';ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      let x=c*CS,y=r*CS;
      let cell=grid[r][c];
      let color=cell.filled?'#0984e3':'#333';
      let bgColor=cell.filled?'#0a1a3a':'#1a1a2e';
      ctx.fillStyle=bgColor;
      ctx.fillRect(x+1,y+1,CS-2,CS-2);
      // Draw pipe
      let cx=x+CS/2,cy=y+CS/2;
      let pw=CS*.22;
      ctx.fillStyle=color;ctx.strokeStyle=color;ctx.lineWidth=pw;ctx.lineCap='round';
      // Center dot
      ctx.beginPath();ctx.arc(cx,cy,pw/2,0,Math.PI*2);ctx.fill();
      // Arms
      cell.openings.forEach(d=>{
        ctx.beginPath();ctx.moveTo(cx,cy);
        if(d===0)ctx.lineTo(cx,y);
        if(d===1)ctx.lineTo(x+CS,cy);
        if(d===2)ctx.lineTo(cx,y+CS);
        if(d===3)ctx.lineTo(x,cy);
        ctx.stroke();
      });
      // Source/drain markers
      if(r===source.r&&c===source.c){
        ctx.fillStyle='#00cec9';ctx.font=Math.floor(CS*.4)+'px sans-serif';ctx.textAlign='center';
        ctx.fillText('üíß',cx,cy+CS*.15);
      }
      if(r===drain.r&&c===drain.c){
        ctx.fillStyle='#e74c3c';ctx.font=Math.floor(CS*.35)+'px sans-serif';ctx.textAlign='center';
        ctx.fillText('üèÅ',cx,cy+CS*.12);
      }
    }
  }
  // Grid lines
  ctx.strokeStyle='#1e1e3a';ctx.lineWidth=1;
  for(let i=0;i<=gridSize;i++){
    ctx.beginPath();ctx.moveTo(i*CS,0);ctx.lineTo(i*CS,canvas.height);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,i*CS);ctx.lineTo(canvas.width,i*CS);ctx.stroke();
  }
}

canvas.addEventListener('click',e=>{
  let rect=canvas.getBoundingClientRect();
  let mx=(e.clientX-rect.left)*(canvas.width/rect.width);
  let my=(e.clientY-rect.top)*(canvas.height/rect.height);
  let c=Math.floor(mx/CS),r=Math.floor(my/CS);
  if(r>=0&&r<gridSize&&c>=0&&c<gridSize)rotatePipe(r,c);
});
canvas.addEventListener('touchend',e=>{
  e.preventDefault();
  let t=e.changedTouches[0];
  let rect=canvas.getBoundingClientRect();
  let mx=(t.clientX-rect.left)*(canvas.width/rect.width);
  let my=(t.clientY-rect.top)*(canvas.height/rect.height);
  let c=Math.floor(mx/CS),r=Math.floor(my/CS);
  if(r>=0&&r<gridSize&&c>=0&&c<gridSize)rotatePipe(r,c);
},{passive:false});

buildSizes();newPuzzle();
</script>
</body>
</html>
