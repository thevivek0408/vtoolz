<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Pac-Man</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#e0e0e0;font-family:'Segoe UI',Arial,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:8px;user-select:none;overflow:hidden}
canvas{display:block;border-radius:4px;touch-action:none}
.info{display:flex;gap:20px;margin-bottom:6px;font-size:.85rem;color:#ffd93d}
.info b{color:#ffd93d}
.controls{display:flex;gap:8px;margin-top:8px}
.controls button{background:#111;border:1px solid #ffd93d33;color:#ffd93d;padding:8px 16px;border-radius:8px;cursor:pointer;font-size:.85rem}
.controls button:hover{background:#ffd93d22}
.dpad{display:none;grid-template-columns:repeat(3,56px);grid-template-rows:repeat(3,56px);gap:4px;margin-top:10px}
.dpad button{background:#111;border:2px solid #ffd93d44;color:#ffd93d;border-radius:12px;cursor:pointer;font-size:1.4rem;-webkit-tap-highlight-color:transparent}
.dpad button:active{background:#ffd93d33}
.dpad .empty-btn{background:transparent;border:none}
@media(pointer:coarse){.dpad{display:grid}}
</style>
</head>
<body>
<div class="info">
  <span>SCORE: <b id="score">0</b></span>
  <span>LIVES: <b id="lives">3</b></span>
  <span>LEVEL: <b id="level">1</b></span>
  <span>HI: <b id="high">0</b></span>
</div>
<canvas id="c"></canvas>
<div class="controls">
  <button onclick="startGame()">New Game</button>
</div>
<div class="dpad" id="dpad">
  <div class="empty-btn"></div><button id="du">▲</button><div class="empty-btn"></div>
  <button id="dl">◀</button><div class="empty-btn"></div><button id="dr">▶</button>
  <div class="empty-btn"></div><button id="dd">▼</button><div class="empty-btn"></div>
</div>
<script>
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');

// Maze: 1=wall, 0=path(dot), 2=empty(no dot), 3=power pellet, 4=ghost house, 5=ghost door
const MAZE_TEMPLATE = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
  [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
  [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
  [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
  [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
  [1,1,1,1,0,1,2,1,1,5,1,1,2,1,0,1,1,1,1],
  [2,2,2,2,0,2,2,1,4,4,4,1,2,2,0,2,2,2,2],
  [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
  [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
  [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
  [1,3,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,3,1],
  [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
  [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
  [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const COLS = 19, ROWS = 21, CS = 24;
const W = COLS * CS, H = ROWS * CS;
canvas.width = W; canvas.height = H;

function rescale() {
  const s = Math.min((window.innerWidth - 16) / W, (window.innerHeight - 140) / H, 1.5);
  canvas.style.width = Math.floor(W * s) + 'px';
  canvas.style.height = Math.floor(H * s) + 'px';
}
rescale(); window.addEventListener('resize', rescale);

const GHOST_COLORS = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'];
const DIR_MAP = { left: { dx: -1, dy: 0 }, right: { dx: 1, dy: 0 }, up: { dx: 0, dy: -1 }, down: { dx: 0, dy: 1 } };
const DIR_LIST = ['up', 'down', 'left', 'right'];
const REVERSE = { left: 'right', right: 'left', up: 'down', down: 'up' };

let maze, pac, ghosts, score, lives, totalDots, dotsLeft, powerTimer, gameRunning, gameOver;
let queuedDir, currentLevel, animFrame, tick;
let highScore = +(localStorage.getItem('pacman-high') || 0);
document.getElementById('high').textContent = highScore;

function isWalkable(x, y) {
  if (y < 0 || y >= ROWS) return false;
  if (x < 0 || x >= COLS) return true; // tunnel wrap
  const v = maze[y][x];
  return v !== 1;
}

function isWalkableForGhost(x, y, canEnterHouse) {
  if (y < 0 || y >= ROWS) return false;
  if (x < 0 || x >= COLS) return true;
  const v = maze[y][x];
  if (v === 1) return false;
  if (v === 5 && !canEnterHouse) return false;
  return true;
}

function wrapX(x) { return (x + COLS) % COLS; }

function dist(x1, y1, x2, y2) { return (x1 - x2) ** 2 + (y1 - y2) ** 2; }

function startGame() {
  currentLevel = 1;
  score = 0; lives = 3;
  document.getElementById('score').textContent = '0';
  document.getElementById('lives').textContent = '3';
  document.getElementById('level').textContent = '1';
  gameOver = false;
  loadLevel();
}

function loadLevel() {
  maze = MAZE_TEMPLATE.map(r => [...r]);
  totalDots = 0;
  maze.forEach(r => r.forEach(v => { if (v === 0 || v === 3) totalDots++; }));
  dotsLeft = totalDots;
  powerTimer = 0; tick = 0;
  queuedDir = null;
  gameRunning = true;

  pac = { x: 9, y: 15, dir: 'left', mouth: 0, mouthOpen: true };
  ghosts = GHOST_COLORS.map((color, i) => ({
    x: 8 + i, y: 9, dir: 'up', color,
    scared: false, eaten: false,
    homeTimer: i * 80 + 20,
    target: { x: 0, y: 0 },
    inHouse: true,
    moveDelay: 0
  }));

  if (animFrame) cancelAnimationFrame(animFrame);
  loop();
}

function loop() {
  if (!gameRunning) return;
  update();
  draw();
  animFrame = requestAnimationFrame(loop);
}

function update() {
  tick++;
  const pacSpeed = 4; // move every N frames
  const ghostSpeed = Math.max(3, 5 - Math.floor(currentLevel / 3)); // ghosts get faster

  // --- PAC-MAN MOVEMENT ---
  if (tick % pacSpeed === 0) {
    // Try queued direction first
    if (queuedDir) {
      const nd = DIR_MAP[queuedDir];
      const nx = wrapX(pac.x + nd.dx), ny = pac.y + nd.dy;
      if (isWalkable(nx, ny)) { pac.dir = queuedDir; queuedDir = null; }
    }
    const d = DIR_MAP[pac.dir];
    const nx = wrapX(pac.x + d.dx), ny = pac.y + d.dy;
    if (isWalkable(nx, ny)) {
      pac.x = nx; pac.y = ny;
      // Eat dots
      const cell = maze[pac.y] && maze[pac.y][pac.x];
      if (cell === 0 || cell === 3) {
        const isPower = cell === 3;
        maze[pac.y][pac.x] = 2;
        dotsLeft--;
        score += isPower ? 50 : 10;
        document.getElementById('score').textContent = score;
        if (isPower) {
          powerTimer = Math.max(180, 300 - currentLevel * 20);
          ghosts.forEach(g => { if (!g.eaten && !g.inHouse) { g.scared = true; g.dir = REVERSE[g.dir]; } });
        }
        if (dotsLeft <= 0) {
          gameRunning = false;
          currentLevel++;
          document.getElementById('level').textContent = currentLevel;
          setTimeout(loadLevel, 1200);
          return;
        }
      }
    }
    // Mouth animation
    pac.mouth += pac.mouthOpen ? 0.12 : -0.12;
    if (pac.mouth >= 0.35) pac.mouthOpen = false;
    if (pac.mouth <= 0.02) pac.mouthOpen = true;
  }

  // --- POWER TIMER ---
  if (powerTimer > 0) {
    powerTimer--;
    if (powerTimer <= 0) ghosts.forEach(g => g.scared = false);
  }

  // --- GHOST MOVEMENT ---
  ghosts.forEach((g, gi) => {
    if (g.homeTimer > 0) { g.homeTimer--; return; }

    // Leave ghost house
    if (g.inHouse) {
      g.x = 9; g.y = 8; g.inHouse = false; g.dir = 'up';
      const ny = g.y + DIR_MAP['up'].dy;
      if (isWalkableForGhost(g.x, ny, true)) { g.y = ny; }
      return;
    }

    if (tick % ghostSpeed !== 0) return;

    // Eaten ghost returns home
    if (g.eaten) {
      const homeX = 9, homeY = 9;
      if (g.x === homeX && g.y === homeY) {
        g.eaten = false; g.inHouse = false; g.scared = false;
        g.dir = 'up';
        return;
      }
      // Pathfind toward home
      chooseGhostDir(g, homeX, homeY, true);
      const d = DIR_MAP[g.dir];
      g.x = wrapX(g.x + d.dx); g.y = g.y + d.dy;
      return;
    }

    // Ghost AI targets
    let tx, ty;
    if (g.scared) {
      // Run away - random target
      tx = Math.floor(Math.random() * COLS);
      ty = Math.floor(Math.random() * ROWS);
    } else {
      // Each ghost has unique targeting
      switch (gi) {
        case 0: // Blinky: direct chase
          tx = pac.x; ty = pac.y; break;
        case 1: // Pinky: 4 tiles ahead of pac
          tx = pac.x + DIR_MAP[pac.dir].dx * 4;
          ty = pac.y + DIR_MAP[pac.dir].dy * 4;
          break;
        case 2: // Inky: complex targeting
          tx = pac.x + DIR_MAP[pac.dir].dx * 2;
          ty = pac.y + DIR_MAP[pac.dir].dy * 2;
          tx = tx * 2 - ghosts[0].x;
          ty = ty * 2 - ghosts[0].y;
          break;
        case 3: // Clyde: chase if far, scatter if close
          if (dist(g.x, g.y, pac.x, pac.y) > 64) { tx = pac.x; ty = pac.y; }
          else { tx = 0; ty = ROWS - 1; }
          break;
      }
    }
    g.target = { x: tx, y: ty };
    chooseGhostDir(g, tx, ty, false);
    const d = DIR_MAP[g.dir];
    const nx = wrapX(g.x + d.dx), ny = g.y + d.dy;
    g.x = nx; g.y = ny;
  });

  // --- COLLISION CHECK ---
  ghosts.forEach(g => {
    if (g.inHouse || (g.eaten)) return;
    if (g.x === pac.x && g.y === pac.y) {
      if (g.scared) {
        g.eaten = true; g.scared = false;
        score += 200; document.getElementById('score').textContent = score;
      } else {
        // Pac dies
        lives--;
        document.getElementById('lives').textContent = lives;
        if (lives <= 0) { gameRunning = false; endGame(); return; }
        // Reset positions
        pac.x = 9; pac.y = 15; pac.dir = 'left'; queuedDir = null;
        ghosts.forEach((gg, i) => {
          gg.x = 8 + i; gg.y = 9; gg.homeTimer = i * 80 + 20;
          gg.scared = false; gg.eaten = false; gg.inHouse = true;
        });
        powerTimer = 0;
      }
    }
  });
}

function chooseGhostDir(g, tx, ty, canGoHome) {
  // At each intersection, pick direction closest to target (never reverse)
  let bestDir = g.dir, bestDist = Infinity;
  let options = 0;

  DIR_LIST.forEach(dir => {
    if (dir === REVERSE[g.dir]) return; // no reversing
    const d = DIR_MAP[dir];
    const nx = wrapX(g.x + d.dx), ny = g.y + d.dy;
    if (!isWalkableForGhost(nx, ny, canGoHome)) return;
    options++;
    const dd = dist(nx, ny, tx, ty);
    if (dd < bestDist) { bestDist = dd; bestDir = dir; }
  });

  // If no forward options, allow reverse
  if (options === 0) {
    const rev = REVERSE[g.dir];
    const d = DIR_MAP[rev];
    const nx = wrapX(g.x + d.dx), ny = g.y + d.dy;
    if (isWalkableForGhost(nx, ny, canGoHome)) bestDir = rev;
  }

  g.dir = bestDir;
}

function draw() {
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);

  // --- MAZE ---
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const v = maze[r][c];
      const x = c * CS, y = r * CS;
      if (v === 1) {
        // Draw walls with rounded look
        ctx.fillStyle = '#1a1aff';
        ctx.fillRect(x + 1, y + 1, CS - 2, CS - 2);
        ctx.fillStyle = '#1111aa';
        ctx.fillRect(x + 3, y + 3, CS - 6, CS - 6);
      }
      if (v === 0) { // dot
        ctx.fillStyle = '#ffb8ae';
        ctx.beginPath(); ctx.arc(x + CS / 2, y + CS / 2, 2.5, 0, Math.PI * 2); ctx.fill();
      }
      if (v === 3) { // power pellet (blinks)
        if (tick % 20 < 14) {
          ctx.fillStyle = '#ffb8ae';
          ctx.beginPath(); ctx.arc(x + CS / 2, y + CS / 2, 6, 0, Math.PI * 2); ctx.fill();
        }
      }
      if (v === 5) { // ghost door
        ctx.fillStyle = '#ffb8ae77';
        ctx.fillRect(x + 2, y + CS / 2 - 1, CS - 4, 3);
      }
    }
  }

  // --- PAC-MAN ---
  const px = pac.x * CS + CS / 2, py = pac.y * CS + CS / 2;
  const angles = { right: 0, down: Math.PI / 2, left: Math.PI, up: Math.PI * 1.5 };
  const a = angles[pac.dir] || 0;
  ctx.fillStyle = '#ffd93d';
  ctx.beginPath();
  ctx.arc(px, py, CS / 2 - 2, a + pac.mouth, a + Math.PI * 2 - pac.mouth);
  ctx.lineTo(px, py);
  ctx.fill();
  // Eye
  const ex = px + Math.cos(a - 0.8) * 6, ey = py + Math.sin(a - 0.8) * 6;
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(ex, ey, 2, 0, Math.PI * 2); ctx.fill();

  // --- GHOSTS ---
  ghosts.forEach(g => {
    if (g.inHouse && g.homeTimer > 0) {
      // Draw in house position
      drawGhost(g.x * CS + CS / 2, g.y * CS + CS / 2, g.color + '88', g);
      return;
    }
    if (g.eaten) {
      // Just draw eyes
      drawGhostEyes(g.x * CS + CS / 2, g.y * CS + CS / 2, g);
      return;
    }
    const gx = g.x * CS + CS / 2, gy = g.y * CS + CS / 2;
    let color;
    if (g.scared) {
      color = (powerTimer < 60 && tick % 10 < 5) ? '#fff' : '#2222ff';
    } else {
      color = g.color;
    }
    drawGhost(gx, gy, color, g);
  });

  // --- LIVES ---
  for (let i = 0; i < lives - 1; i++) {
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath();
    ctx.arc(20 + i * 25, H - 14, 8, 0.3, Math.PI * 2 - 0.3);
    ctx.lineTo(20 + i * 25, H - 14);
    ctx.fill();
  }
}

function drawGhost(gx, gy, color, g) {
  const r = CS / 2 - 2;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(gx, gy - 3, r, Math.PI, 0);
  ctx.lineTo(gx + r, gy + r - 2);
  for (let i = 0; i < 4; i++) {
    const bx = gx + r - i * (2 * r / 4);
    const wave = (i % 2 === 0) ? -4 : 0;
    ctx.lineTo(bx - r / 4, gy + r - 2 + wave);
  }
  ctx.lineTo(gx - r, gy + r - 2);
  ctx.closePath();
  ctx.fill();

  if (!g.scared) drawGhostEyes(gx, gy, g);
  else {
    // Scared face
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + 4, gy - 4, 2, 0, Math.PI * 2); ctx.fill();
    // Wavy mouth
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(gx - 5, gy + 3);
    for (let i = 0; i < 5; i++) ctx.lineTo(gx - 5 + i * 2.5, gy + 3 + (i % 2 ? -2 : 0));
    ctx.stroke();
  }
}

function drawGhostEyes(gx, gy, g) {
  const d = DIR_MAP[g.dir] || { dx: 0, dy: 0 };
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(gx - 4, gy - 4, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(gx + 4, gy - 4, 4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#00f';
  ctx.beginPath(); ctx.arc(gx - 4 + d.dx * 2, gy - 4 + d.dy * 2, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(gx + 4 + d.dx * 2, gy - 4 + d.dy * 2, 2, 0, Math.PI * 2); ctx.fill();
}

function endGame() {
  gameOver = true;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('pacman-high', highScore);
    document.getElementById('high').textContent = highScore;
  }
  ctx.fillStyle = 'rgba(0,0,0,.75)'; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#ffd93d'; ctx.font = 'bold 30px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', W / 2, H / 2 - 20);
  ctx.font = '16px Segoe UI';
  ctx.fillText('Score: ' + score, W / 2, H / 2 + 15);
  ctx.fillText('Click or press any key to restart', W / 2, H / 2 + 40);
}

// --- KEYBOARD CONTROLS ---
document.addEventListener('keydown', e => {
  const key = e.key;
  if (key === 'ArrowLeft' || key === 'a') { e.preventDefault(); queuedDir = 'left'; }
  else if (key === 'ArrowRight' || key === 'd') { e.preventDefault(); queuedDir = 'right'; }
  else if (key === 'ArrowUp' || key === 'w') { e.preventDefault(); queuedDir = 'up'; }
  else if (key === 'ArrowDown' || key === 's') { e.preventDefault(); queuedDir = 'down'; }
  if (gameOver) startGame();
});

// --- D-PAD TOUCH CONTROLS ---
const dpadMap = { du: 'up', dd: 'down', dl: 'left', dr: 'right' };
Object.entries(dpadMap).forEach(([id, dir]) => {
  const btn = document.getElementById(id);
  btn.addEventListener('touchstart', e => { e.preventDefault(); queuedDir = dir; }, { passive: false });
  btn.addEventListener('mousedown', e => { e.preventDefault(); queuedDir = dir; });
});

// --- SWIPE CONTROLS ---
let swipeStart = null;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  swipeStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
}, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
canvas.addEventListener('touchend', e => {
  if (!swipeStart) return;
  const dx = e.changedTouches[0].clientX - swipeStart.x;
  const dy = e.changedTouches[0].clientY - swipeStart.y;
  if (Math.max(Math.abs(dx), Math.abs(dy)) < 15) {
    if (gameOver) startGame();
    swipeStart = null; return;
  }
  if (Math.abs(dx) > Math.abs(dy)) queuedDir = dx > 0 ? 'right' : 'left';
  else queuedDir = dy > 0 ? 'down' : 'up';
  swipeStart = null;
});

canvas.addEventListener('click', () => { if (gameOver) startGame(); });

startGame();
</script>
</body>
</html>
