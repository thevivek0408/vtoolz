<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #header { display: flex; align-items: center; gap: 24px; margin-bottom: 12px; color: #e0e0e0; font-size: 18px; }
        #header span { font-weight: bold; }
        #score-val, #high-val { color: #4ecca3; }
        canvas { border: 2px solid #4ecca3; border-radius: 8px; background: #16213e; display: block; touch-action: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); color: #fff; z-index: 10; }
        #overlay h1 { font-size: 32px; margin-bottom: 8px; color: #4ecca3; }
        #overlay p { font-size: 16px; margin-bottom: 16px; opacity: 0.8; }
        #overlay .btn { padding: 12px 32px; font-size: 18px; border: none; border-radius: 8px; background: #4ecca3; color: #1a1a2e; cursor: pointer; font-weight: bold; }
        #overlay .btn:hover { background: #3bb391; }
        #game-over-text { display: none; font-size: 22px; color: #e74c3c; margin-bottom: 8px; }
        #wrap { position: relative; }
    </style>
</head>
<body>
    <div id="header">
        <span>Score: <span id="score-val">0</span></span>
        <span>Best: <span id="high-val">0</span></span>
    </div>
    <div id="wrap">
        <canvas id="game"></canvas>
        <div id="overlay">
            <h1>üêç Snake</h1>
            <p id="game-over-text">Game Over!</p>
            <p>Use arrow keys or swipe to play</p>
            <button class="btn" id="startBtn">Play</button>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startBtn');
        const scoreVal = document.getElementById('score-val');
        const highVal = document.getElementById('high-val');
        const gameOverText = document.getElementById('game-over-text');

        const GRID = 20;
        let cols, rows, cellSize;
        let snake, dir, nextDir, food, score, highScore, running, speed, gameLoop;

        function resize() {
            const maxW = Math.min(window.innerWidth - 20, 500);
            const maxH = Math.min(window.innerHeight - 80, 500);
            const size = Math.min(maxW, maxH);
            cellSize = Math.floor(size / GRID);
            canvas.width = cellSize * GRID;
            canvas.height = cellSize * GRID;
            cols = GRID; rows = GRID;
        }

        function init() {
            highScore = parseInt(localStorage.getItem('snake-high') || '0');
            highVal.textContent = highScore;
            resize();
        }

        function startGame() {
            snake = [{x: 10, y: 10}];
            dir = {x: 1, y: 0};
            nextDir = {x: 1, y: 0};
            score = 0;
            speed = 120;
            scoreVal.textContent = '0';
            overlay.style.display = 'none';
            gameOverText.style.display = 'none';
            placeFood();
            running = true;
            clearInterval(gameLoop);
            gameLoop = setInterval(update, speed);
        }

        function placeFood() {
            let pos;
            do {
                pos = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
            } while (snake.some(s => s.x === pos.x && s.y === pos.y));
            food = pos;
        }

        function update() {
            if (!running) return;
            dir = {...nextDir};
            const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

            // Wall collision
            if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) return gameOver();
            // Self collision
            if (snake.some(s => s.x === head.x && s.y === head.y)) return gameOver();

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreVal.textContent = score;
                if (score > highScore) { highScore = score; highVal.textContent = highScore; localStorage.setItem('snake-high', highScore); }
                placeFood();
                if (speed > 60) { speed -= 2; clearInterval(gameLoop); gameLoop = setInterval(update, speed); }
            } else {
                snake.pop();
            }
            draw();
        }

        function draw() {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Food
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(food.x * cellSize + cellSize/2, food.y * cellSize + cellSize/2, cellSize/2 - 2, 0, Math.PI*2);
            ctx.fill();

            // Snake
            snake.forEach((seg, i) => {
                ctx.fillStyle = i === 0 ? '#4ecca3' : '#38b28a';
                ctx.fillRect(seg.x * cellSize + 1, seg.y * cellSize + 1, cellSize - 2, cellSize - 2);
                ctx.strokeStyle = '#16213e';
                ctx.lineWidth = 1;
                ctx.strokeRect(seg.x * cellSize + 1, seg.y * cellSize + 1, cellSize - 2, cellSize - 2);
            });
        }

        function gameOver() {
            running = false;
            clearInterval(gameLoop);
            gameOverText.style.display = 'block';
            startBtn.textContent = 'Play Again';
            overlay.style.display = 'flex';
        }

        // Keyboard
        document.addEventListener('keydown', e => {
            if (!running) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': e.preventDefault(); if (dir.y !== 1) nextDir = {x:0, y:-1}; break;
                case 'ArrowDown': case 's': e.preventDefault(); if (dir.y !== -1) nextDir = {x:0, y:1}; break;
                case 'ArrowLeft': case 'a': e.preventDefault(); if (dir.x !== 1) nextDir = {x:-1, y:0}; break;
                case 'ArrowRight': case 'd': e.preventDefault(); if (dir.x !== -1) nextDir = {x:1, y:0}; break;
            }
        });

        // Touch swipe
        let tx, ty;
        canvas.addEventListener('touchstart', e => { tx = e.changedTouches[0].screenX; ty = e.changedTouches[0].screenY; }, {passive: true});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); }, {passive: false});
        canvas.addEventListener('touchend', e => {
            if (!running) return;
            const dx = e.changedTouches[0].screenX - tx;
            const dy = e.changedTouches[0].screenY - ty;
            if (Math.max(Math.abs(dx), Math.abs(dy)) < 20) return;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && dir.x !== -1) nextDir = {x:1, y:0};
                else if (dx < 0 && dir.x !== 1) nextDir = {x:-1, y:0};
            } else {
                if (dy > 0 && dir.y !== -1) nextDir = {x:0, y:1};
                else if (dy < 0 && dir.y !== 1) nextDir = {x:0, y:-1};
            }
        }, {passive: true});

        startBtn.addEventListener('click', startGame);
        window.addEventListener('resize', () => { resize(); if (running) draw(); });
        init();
    })();
    </script>
</body>
</html>
