<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Art Studio - Vibox</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* ASCII Studio Specific Styles using Grid/Flex */
        body {
            overflow: hidden;
            /* App-like feel */
        }

        .studio-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
            width: 100vw;
            background: var(--bg-color);
            color: var(--text-color);
        }

        /* Sidebar */
        .sidebar {
            background: var(--surface-color);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .logo-text {
            font-size: 1.2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .control-group h3 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .range-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-picker-row {
            display: flex;
            gap: 10px;
        }

        .color-input {
            flex: 1;
            height: 35px;
            padding: 2px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            background: none;
        }

        /* Preview Area */
        .preview-area {
            display: flex;
            flex-direction: column;
            background: var(--preview-bg, #000);
            /* Dynamic BG */
            position: relative;
            overflow: hidden;
            transition: background 0.3s;
        }

        .preview-toolbar {
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            color: #ccc;
        }

        .output-wrapper {
            flex-grow: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Center initially */
            padding: 20px;
            cursor: move;
            /* Hint draggable if we add pan */
        }

        .ascii-output {
            font-family: 'Courier New', monospace;
            white-space: pre;
            color: var(--preview-fg, #fff);
            /* Dynamic FG */
            line-height: var(--line-height, 0.8);
            font-size: var(--font-size, 10px);
            transform-origin: center;
            transition: color 0.2s;
        }

        /* Matrix Effect */
        .ascii-output.matrix {
            color: #0f0 !important;
            text-shadow: 0 0 5px #0f0;
        }

        /* Styled Segmented Control (Tabs) */
        .tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tabs button {
            flex: 1;
            background: transparent;
            border: none;
            color: #888;
            padding: 6px 0;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tabs button.active {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Modern Inputs */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            margin-top: 10px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        select.form-control,
        input[type="text"].form-control {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            width: 100%;
            font-family: inherit;
        }

        select.form-control:focus,
        input[type="text"].form-control:focus {
            border-color: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        /* Color Inputs */
        .color-input {
            width: 100%;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        .color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-input::-webkit-color-swatch {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        /* Custom Toggles - Premium */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .studio-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .sidebar {
                height: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }
        }
    </style>
</head>

<body>

    <div class="studio-container">
        <!-- Sidebar Controls -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <a href="../../index.html" style="color:var(--text-color)"><i class="fas fa-chevron-left"></i></a>
                <span class="logo-text">ASCII Studio</span>
            </div>

            <!-- Mode Selection -->
            <div class="control-group">
                <h3>Source</h3>
                <div class="control-item">
                    <div class="tabs"
                        style="display:flex; gap:5px; background:rgba(0,0,0,0.1); padding:5px; border-radius:8px;">
                        <button class="btn btn-sm btn-primary" id="modeImg" style="flex:1;">Image</button>
                        <button class="btn btn-sm btn-secondary" id="modeVid" style="flex:1;">Camera</button>
                        <button class="btn btn-sm btn-secondary" id="modeText" style="flex:1;">Text</button>
                    </div>
                </div>

                <!-- Image Controls -->
                <div id="imgControls" class="control-item">
                    <label>Upload Image</label>
                    <input type="file" id="fileInput" accept="image/*" class="form-control" style="font-size:0.8rem;">
                </div>

                <!-- Text Controls -->
                <div id="textControls" class="control-item" style="display:none;">
                    <label>Enter Text</label>
                    <input type="text" id="textInput" class="form-control" placeholder="Type text..." value="VIBOX">
                    <label style="margin-top:10px">Font Style</label>
                    <select id="fontSelect" class="form-control">
                        <option value="monospace">Monospace</option>
                        <option value="sans-serif">Sans Serif</option>
                        <option value="serif">Serif</option>
                        <option value="cursive">Cursive</option>
                        <option value="fantasy">Fantasy</option>
                    </select>
                </div>
            </div>

            <!-- Settings -->
            <div class="control-group">
                <h3>Appearance</h3>

                <div class="control-item">
                    <label>Character Set</label>
                    <select id="charSet" class="form-control">
                        <option value="standard">Standard (70 chars)</option>
                        <option value="simple">Simple (10 chars)</option>
                        <option value="minimal">Minimal (3 chars)</option>
                        <option value="blocks">Blocks (Shading)</option>
                        <option value="binary">Binary (Matrix)</option>
                        <option value="custom">Custom...</option>
                    </select>
                    <input type="text" id="customCharInput" class="form-control" placeholder="e.g. @#$%"
                        style="display:none; margin-top:10px;" value="@#$%">
                </div>

                <div class="control-item">
                    <div style="display:flex; justify-content:space-between;">
                        <label>Resolution</label>
                        <span id="resDisp" style="font-size:0.8rem; opacity:0.7;">100 chars</span>
                    </div>
                    <input type="range" id="resolution" min="20" max="300" value="100" style="width:100%">
                </div>

                <div class="control-item">
                    <div style="display:flex; justify-content:space-between;">
                        <label>Font Size</label>
                        <span id="sizeDisp" style="font-size:0.8rem; opacity:0.7;">10px</span>
                    </div>
                    <input type="range" id="fontSize" min="4" max="24" value="10" style="width:100%">
                </div>
            </div>

            <!-- Color & Effects -->
            <div class="control-group">
                <h3>Color & Effects</h3>

                <div class="control-item">
                    <label>Colors</label>
                    <div class="color-picker-row">
                        <div style="flex:1">
                            <label style="font-size:0.7rem">Text</label>
                            <input type="color" id="fgColor" class="color-input" value="#ffffff">
                        </div>
                        <div style="flex:1">
                            <label style="font-size:0.7rem">Bg</label>
                            <input type="color" id="bgColor" class="color-input" value="#000000">
                        </div>
                    </div>
                </div>

                <div class="control-item" style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="margin:0">Matrix Mode</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="matrixToggle">
                        <span class="slider"></span>
                    </label>
                </div>

            </div>

            <button id="copyBtn" class="btn btn-primary btn-block"><i class="fas fa-copy"></i> Copy Text</button>
        </aside>

        <!-- Main Preview -->
        <main class="preview-area">
            <div class="preview-toolbar">
                <span>PREVIEW</span>
                <div>
                    <span id="dims" style="font-size:0.8rem; margin-right:10px;">0 x 0</span>
                    <button id="dlBtn" class="btn btn-sm btn-secondary"><i class="fas fa-download"></i> Save
                        PNG</button>
                </div>
            </div>

            <div class="output-wrapper" id="wrapper">
                <div id="asciiOutput" class="ascii-output">Select an image or start camera...</div>
            </div>

            <!-- Hidden Video for Processing -->
            <video id="videoFeed" style="display:none;" autoplay playsinline></video>
        </main>
    </div>

    <script type="module">
        import '../../js/utils/common.js';

        // State
        const state = {
            mode: 'image', // image | video | text
            resolution: 100,
            fontSize: 10,
            matrix: false,
            fgColor: '#ffffff',
            bgColor: '#000000',
            charSet: 'simple',
            isCamRunning: false,
            textValue: 'VIBOX',
            textFont: 'monospace'
        };

        // Elements
        const els = {
            output: document.getElementById('asciiOutput'),
            wrapper: document.getElementById('wrapper'),
            previewArea: document.querySelector('.preview-area'),
            fileInput: document.getElementById('fileInput'),
            video: document.getElementById('videoFeed'),
            resInput: document.getElementById('resolution'),
            sizeInput: document.getElementById('fontSize'),
            resDisp: document.getElementById('resDisp'),
            sizeDisp: document.getElementById('sizeDisp'),
            matrixToggle: document.getElementById('matrixToggle'),
            matrixToggle: document.getElementById('matrixToggle'),
            charSet: document.getElementById('charSet'),
            customCharInput: document.getElementById('customCharInput'),
            modeImg: document.getElementById('modeImg'),
            modeVid: document.getElementById('modeVid'),
            modeText: document.getElementById('modeText'),
            imgControls: document.getElementById('imgControls'),
            textControls: document.getElementById('textControls'),
            textInput: document.getElementById('textInput'),
            fontSelect: document.getElementById('fontSelect'),
            fgColor: document.getElementById('fgColor'),
            bgColor: document.getElementById('bgColor')
        };

        // Charsets (Ordered: Dark(0)/Low -> Light(255)/High)
        // Since we draw White Text on Black BG, High Value (255) should be Dense Char
        const charsets = {
            standard: " .'`^,:;Il!i><~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$",
            simple: " .:-=+*#%@",
            minimal: " .@",
            blocks: " ░▒▓█",
            binary: "01"
        };

        let animationId;

        // --- Init ---
        function init() {
            // Event Listeners
            els.resInput.addEventListener('input', updateParams);
            els.sizeInput.addEventListener('input', updateParams);
            els.matrixToggle.addEventListener('change', updateParams);
            els.matrixToggle.addEventListener('change', updateParams);
            els.charSet.addEventListener('change', (e) => {
                if (e.target.value === 'custom') els.customCharInput.style.display = 'block';
                else els.customCharInput.style.display = 'none';
                updateParams();
            });
            els.customCharInput.addEventListener('input', updateParams);
            els.fgColor.addEventListener('input', updateParams);
            els.bgColor.addEventListener('input', updateParams);

            els.modeImg.addEventListener('click', () => setMode('image'));
            els.modeVid.addEventListener('click', () => setMode('video'));
            els.modeText.addEventListener('click', () => setMode('text'));

            els.fileInput.addEventListener('change', handleFile);

            // Text Mode Listeners
            els.textInput.addEventListener('input', (e) => { state.textValue = e.target.value; updateParams(); });
            els.fontSelect.addEventListener('change', (e) => { state.textFont = e.target.value; updateParams(); });

            document.getElementById('copyBtn').addEventListener('click', copyText);
            document.getElementById('dlBtn').addEventListener('click', saveToPNG);
        }

        function setMode(mode) {
            state.mode = mode;
            stopCamera();

            // Reset buttons
            [els.modeImg, els.modeVid, els.modeText].forEach(b => b.classList.replace('btn-primary', 'btn-secondary'));
            els.imgControls.style.display = 'none';
            els.textControls.style.display = 'none';

            if (mode === 'image') {
                els.modeImg.classList.replace('btn-secondary', 'btn-primary');
                els.imgControls.style.display = 'block';
                els.output.textContent = "Select an image...";
            } else if (mode === 'video') {
                els.modeVid.classList.replace('btn-secondary', 'btn-primary');
                startCamera();
            } else if (mode === 'text') {
                els.modeText.classList.replace('btn-secondary', 'btn-primary');
                els.textControls.style.display = 'block';
                renderTextMode();
            }
        }

        function updateParams() {
            state.resolution = parseInt(els.resInput.value);
            state.fontSize = parseInt(els.sizeInput.value);
            state.matrix = els.matrixToggle.checked;
            state.matrix = els.matrixToggle.checked;
            state.charSet = els.charSet.value;
            state.customChars = els.customCharInput.value;
            state.fgColor = els.fgColor.value;
            state.bgColor = els.bgColor.value;

            // Update UI Text
            els.resDisp.textContent = `${state.resolution} chars`;
            els.sizeDisp.textContent = `${state.fontSize}px`;

            // Update CSS Styles
            els.output.style.fontSize = `${state.fontSize}px`;
            els.output.style.lineHeight = `${state.fontSize * 0.6}px`; // Tight scaling

            if (state.matrix) {
                els.output.classList.add('matrix');
                // Matrix overrides custom colors
            } else {
                els.output.classList.remove('matrix');
                els.output.style.color = state.fgColor;
            }

            els.previewArea.style.setProperty('--preview-bg', state.bgColor);
            els.output.style.setProperty('--preview-fg', state.fgColor);

            // Re-render based on mode
            if (state.mode === 'image' && els.fileInput.files[0]) {
                handleFile({ target: els.fileInput });
            } else if (state.mode === 'text') {
                renderTextMode();
            }
        }

        // --- Camera ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                els.video.srcObject = stream;
                state.isCamRunning = true;
                loop();
            } catch (e) {
                alert("Camera Error: " + e);
            }
        }

        function stopCamera() {
            state.isCamRunning = false;
            cancelAnimationFrame(animationId);
            if (els.video.srcObject) {
                els.video.srcObject.getTracks().forEach(t => t.stop());
                els.video.srcObject = null;
            }
        }

        function loop() {
            if (!state.isCamRunning) return;
            renderASCII(els.video);
            animationId = requestAnimationFrame(loop);
        }

        // --- Image ---
        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => renderASCII(img);
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- Core Engine ---
        function renderASCII(source) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const w = state.resolution;
            const srcW = source.videoWidth || source.width;
            const srcH = source.videoHeight || source.height;

            if (!srcW || !srcH) return;

            const ratio = srcH / srcW;
            const h = Math.floor(w * ratio * 0.55); // Aspect fix

            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(source, 0, 0, w, h);

            const data = ctx.getImageData(0, 0, w, h).data;
            let currentChars = charsets[state.charSet];
            if (state.charSet === 'custom') currentChars = state.customChars;
            if (!currentChars || currentChars.length === 0) currentChars = charsets.simple;

            // Ensure charset is ordered from Dark to Light (Density)
            // If user types "AB", we assume they want A=Dark, B=Light or vice versa.
            // But standard ascii algos use density maps. 
            // We just reverse if needed? No, let's keep it raw for custom.
            const chars = currentChars.split('');
            let str = "";

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const idx = Math.floor((avg / 255) * (chars.length - 1));
                    str += chars[idx];
                }
                str += "\n";
            }
            els.output.textContent = str;

            // Update dimensions info
            document.getElementById('dims').textContent = `${w} x ${h}`;
        }

        // --- Text Mode ---
        function renderTextMode() {
            const text = state.textValue || "";
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Measure roughly
            ctx.font = `bold 100px ${state.textFont}`;
            const metrics = ctx.measureText(text);
            const textW = Math.ceil(metrics.width) + 40;
            const textH = 150; // Padding

            canvas.width = textW;
            canvas.height = textH;

            // Draw White text on Black background (Engine expects brightness)
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, textW, textH);
            ctx.fillStyle = "white";
            ctx.font = `bold 100px ${state.textFont}`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, textW / 2, textH / 2);

            // Send to ASCII engine
            renderASCII(canvas);
        }

        // --- Actions ---
        function copyText() {
            navigator.clipboard.writeText(els.output.textContent);
            alert("ASCII copied!");
        }

        function saveToPNG() {
            const lines = els.output.textContent.split('\n');
            // Render high-res
            const fontSize = state.fontSize * 2;
            const lineHeight = fontSize * 0.6;
            const charW = fontSize * 0.6;

            // Calculate canvas size
            const maxLine = Math.max(...lines.map(l => l.length));
            const cvsW = maxLine * charW + 40;
            const cvsH = lines.length * lineHeight + 40;

            const canvas = document.createElement('canvas');
            canvas.width = cvsW;
            canvas.height = cvsH;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = state.bgColor;
            ctx.fillRect(0, 0, cvsW, cvsH);

            // Text
            ctx.font = `${fontSize}px 'Courier New', monospace`;
            ctx.fillStyle = state.matrix ? '#0f0' : state.fgColor;

            if (state.matrix) {
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#0f0';
            }

            let y = 30; // padding top
            lines.forEach(line => {
                ctx.fillText(line, 20, y);
                y += lineHeight;
            });

            // Download
            const link = document.createElement('a');
            link.download = `ascii-${state.mode}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // Start
        init();

    </script>
</body>

</html>